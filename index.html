<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>競艇 v1（段階表示＋おすすめ条件v2）</title>
  <style>
    body { font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; margin:0; background:#0b0f14; color:#e9eef5; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    h1 { font-size: 18px; margin: 8px 0 10px; }
    .sub { font-size: 12px; color:#b8c5d6; margin-bottom: 10px; line-height:1.6; }

    .card { background:#121a24; border:1px solid #1c2a3b; border-radius:14px; padding:14px; margin:10px 0; box-shadow:0 6px 18px rgba(0,0,0,.25); }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid #2a3e5b; background:#0d141d; color:#cfe3ff; }

    .grid { display:grid; gap:10px; }
    .g2 { grid-template-columns: 1fr 1fr; }
    .g3 { grid-template-columns: 1fr 1fr 1fr; }
    @media (max-width: 760px) { .g2,.g3 { grid-template-columns: 1fr; } }

    label { font-size:12px; color:#b8c5d6; display:block; margin-bottom:6px; }
    input, select { width:100%; padding:10px; border-radius:10px; border:1px solid #223248; background:#0d141d; color:#e9eef5; font-size:14px; box-sizing:border-box; }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .rowL { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .btn { background:#2b6ff7; border:0; color:#fff; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; }
    .btn2 { background:#223248; border:1px solid #2a3e5b; color:#e9eef5; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; }
    .btnDanger { background:#7f1d1d; border:1px solid #991b1b; color:#fff; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; }

    .muted { color:#b8c5d6; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    .hr { height:1px; background:#223248; margin:12px 0; }

    .badge { display:inline-block; padding:3px 10px; border-radius:999px; font-size:12px; font-weight:900; border:1px solid #2a3e5b; background:#0d141d; }
    .b-buy { color:#6ee7b7; }
    .b-no { color:#fca5a5; }
    .b-wait { color:#ffd27d; }
    .b-filter { color:#8aa3c7; }

    .raceCard { background:#111a26; border:1px solid #1c2a3b; border-radius:14px; padding:12px; margin:10px 0; }
    .tag { display:inline-block; padding:2px 8px; border:1px solid #2a3e5b; border-radius:999px; font-size:11px; margin-left:8px; color:#b8c5d6; }
    .resultLine { margin-top:6px; color:#b8c5d6; }

    .checkboxes { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .cb { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3e5b; border-radius:999px; background:#0d141d; font-size:12px; color:#e9eef5; }
    .cb input { width:auto; }

    .log { white-space: pre-wrap; background:#0d141d; border:1px solid #223248; border-radius:10px; padding:10px; max-height:160px; overflow:auto; font-size:12px; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>競艇 v1（段階表示＋おすすめ条件v2）</h1>
  <div class="sub">
    ✅ 「出せる条件から先に出す」：programs取得後すぐ一覧表示 → その後に展示/払戻を反映。<br/>
    ✅ 判定：外枠が速いのみでNO（速い相手カウントは判定に使わない）＋ Δ2/Δ3/混戦回避＋オッズ上限。<br/>
    ✅ BUY時の推奨：<b>3連複 1-2-3（1点）</b>（買い目は増やさない）。
  </div>

  <div class="card">
    <div class="pill">条件</div>
    <div class="grid g3" style="margin-top:10px;">
      <div><label>全国2連率(%) 下限</label><input id="minNat2" type="number" step="0.1" value="42" /></div>
      <div><label>当地2連率(%) 下限</label><input id="minLoc2" type="number" step="0.1" value="42" /></div>
      <div><label>モーター2連率(%) 下限</label><input id="minMotor2" type="number" step="0.1" value="40" /></div>
    </div>

    <div class="grid g3" style="margin-top:10px;">
      <div><label>展示：1号艇順位（上位）</label><input id="maxTimeRank" type="number" step="1" value="2" /></div>
      <div><label>混戦回避：近い艇の上限数</label><input id="maxNearCount" type="number" step="1" value="2" /></div>
      <div><label>混戦判定：1号艇 +（秒）以内</label><input id="nearEps" type="number" step="0.01" value="0.03" /></div>
    </div>

    <div class="grid g3" style="margin-top:10px;">
      <div><label>Δ2（2−1）上限</label><input id="maxDelta2" type="number" step="0.01" value="0.12" /></div>
      <div><label>Δ3（3−1）上限</label><input id="maxDelta3" type="number" step="0.01" value="0.15" /></div>
      <div><label>最高オッズ（上限）</label><input id="maxBestOdds" type="number" step="0.1" value="25" /></div>
    </div>

    <div class="grid g2" style="margin-top:10px;">
      <div><label>最低オッズ</label><input id="minBestOdds" type="number" step="0.1" value="6.0" /></div>
      <div class="muted" style="align-self:end;">※BUY推奨：<b>3連複 1-2-3（1点）</b></div>
    </div>

    <div class="hr"></div>

    <div class="pill">集計</div>
    <div class="muted" style="margin-top:8px;" id="summary">-</div>

    <div class="hr"></div>

    <div class="pill">表示モード</div>
    <div class="grid g2" style="margin-top:10px;">
      <div>
        <label>表示</label>
        <select id="viewMode">
          <option value="candidates">候補のみ（条件①通過）</option>
          <option value="all" selected>全件表示（理由確認用）</option>
        </select>
      </div>
      <div style="align-self:end;">
        <button class="btn2" id="applyBtn">適用</button>
      </div>
    </div>

    <div class="hr"></div>

    <div class="pill">対象レース場（全場ON）</div>
    <div class="checkboxes" id="venueChecks"></div>

    <div class="hr"></div>

    <div class="pill">シート送信</div>
    <div class="row" style="margin-top:10px;">
      <div class="rowL">
        <button class="btn" id="sendBuyBtn">送信：BUYのみ</button>
        <button class="btn2" id="sendCandBtn">送信：候補（条件①通過）</button>
        <button class="btn2" id="sendTestBtn">テスト送信（1行）</button>
        <button class="btnDanger" id="clearLocalBtn">オッズ保存を全消去</button>
      </div>
      <div class="muted mono" id="sendStatus">-</div>
    </div>
    <div class="log" id="sendLog">ログ：\n</div>

    <div class="hr"></div>

    <div class="row">
      <div class="rowL">
        <button class="btn" id="refreshBtn">更新</button>
        <label class="cb" style="margin:0;">
          <input type="checkbox" id="autoRefresh" checked />
          展示待ち時に自動更新（20秒）
        </label>
      </div>
      <div class="muted mono">
        <span id="status">-</span> / <span id="autoStatus">-</span>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="pill">レース一覧</div>
    <div id="list"></div>
  </div>
</div>

<script>
(() => {
  // ====== GAS URL ======
  const GAS_URL = "https://script.google.com/macros/s/AKfycbw5C8p_tw_dK9m5OWPrekxfbHz1mNq949fjBq1ymTo8xNCjtIGTRGbmVZYQyO3-O3fo/exec";

  const $ = (id) => document.getElementById(id);
  const n = (id) => {
    const v = $(id).value;
    if (v === "" || v == null) return null;
    const x = Number(v);
    return Number.isFinite(x) ? x : null;
  };

  const VENUES = {
    1:"桐生",2:"戸田",3:"江戸川",4:"平和島",5:"多摩川",6:"浜名湖",7:"蒲郡",8:"常滑",
    9:"津",10:"三国",11:"びわこ",12:"住之江",13:"尼崎",14:"鳴門",15:"丸亀",16:"児島",
    17:"宮島",18:"徳山",19:"下関",20:"若松",21:"芦屋",22:"福岡",23:"唐津",24:"大村"
  };

  let enabledStadiums = new Set(Array.from({length: 24}, (_, i) => i + 1));
  let LAST_RACES = [];

  const PROGRAMS_URL = "https://boatraceopenapi.github.io/programs/v2/today.json";
  const PREVIEWS_URL = "https://boatraceopenapi.github.io/previews/v2/today.json";
  const RESULTS_URL  = "https://boatraceopenapi.github.io/results/v2/today.json";

  // ---- odds cache ----
  const ODDS_KEY = "kyotei_odds_cache_goodshape_payfix3";
  function loadOddsCache() { try { return JSON.parse(localStorage.getItem(ODDS_KEY) || "{}"); } catch { return {}; } }
  function saveOddsCache(cache) { try { localStorage.setItem(ODDS_KEY, JSON.stringify(cache)); } catch {} }
  function getOdds(key) { const c = loadOddsCache(); return c[key] || { o123:"", o132:"" }; }
  function setOdds(key, o123, o132) { const c=loadOddsCache(); c[key]={o123:String(o123??""), o132:String(o132??"")}; saveOddsCache(c); }
  function clearOddsAll() { try { localStorage.removeItem(ODDS_KEY); } catch {} }

  function setStatus(msg) { $("status").textContent = msg; }
  function setAutoStatus(msg) { $("autoStatus").textContent = msg; }
  function setSendStatus(msg) { $("sendStatus").textContent = msg; }
  function logSend(line) {
    const el = $("sendLog");
    el.textContent += line + "\n";
    el.scrollTop = el.scrollHeight;
  }
  function clearSendLog() { $("sendLog").textContent = "ログ：\n"; }

  function nowTimeStr() {
    const d = new Date();
    return d.toLocaleTimeString();
  }

  async function fetchJson(url) {
    const bust = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
    const res = await fetch(bust, { cache:"no-store" });
    if (!res.ok) throw new Error(`fetch failed ${res.status}: ${url}`);
    return await res.json();
  }

  // ===== 判定用の小関数 =====
  function exhReady(exh) {
    for (let lane=1; lane<=3; lane++) {
      const t = Number(exh[String(lane)]);
      if (!Number.isFinite(t) || t <= 0) return false;
    }
    return true;
  }

  function passFilter1(r) {
    const minNat2 = n("minNat2");
    const minLoc2 = n("minLoc2");
    const minMotor2 = n("minMotor2");
    const reasons = [];
    if (minNat2 != null && r.nat2 < minNat2) reasons.push("全国2連率不足");
    if (minLoc2 != null && r.loc2 < minLoc2) reasons.push("当地2連率不足");
    if (minMotor2 != null && r.motor2 < minMotor2) reasons.push("モーター2連率不足");
    return { ok: reasons.length===0, reasons };
  }

  function exhibitionRank(exh) {
    const arr = Object.entries(exh)
      .map(([lane,t])=>({lane:Number(lane), t:Number(t)}))
      .filter(x=>Number.isFinite(x.lane) && Number.isFinite(x.t) && x.t>0)
      .sort((a,b)=>a.t-b.t);
    const idx = arr.findIndex(x=>x.lane===1);
    return idx>=0 ? idx+1 : null;
  }

  function fasterOppLanes(exh) {
    const t1 = Number(exh["1"]);
    if (!Number.isFinite(t1) || t1<=0) return [];
    const lanes=[];
    for (let lane=2; lane<=6; lane++) {
      const t = Number(exh[String(lane)]);
      if (Number.isFinite(t) && t>0 && t < t1) lanes.push(lane);
    }
    return lanes;
  }

  function deltaLane(exh, lane) {
    const t1 = Number(exh["1"]);
    const tx = Number(exh[String(lane)]);
    if (!Number.isFinite(t1) || !Number.isFinite(tx) || t1<=0 || tx<=0) return null;
    return tx - t1;
  }

  function nearCount(exh, eps) {
    const t1 = Number(exh["1"]);
    if (!Number.isFinite(t1) || t1<=0 || !Number.isFinite(eps)) return null;
    let c = 0;
    for (let lane=2; lane<=6; lane++) {
      const t = Number(exh[String(lane)]);
      if (!Number.isFinite(t) || t<=0) continue;
      if (t <= t1 + eps) c++; // 速い(=t1より小さい)も近い扱い
    }
    return c;
  }

  // ===== judge（“出せる条件から先に出す”版）=====
  function judge(r, o123, o132) {
    // ① programs条件（朝すぐ出せる）
    const f1 = passFilter1(r);
    if (!f1.ok) {
      return { state:"条件外", msg:`条件外：${f1.reasons.join(" / ")}` };
    }

    // ② odds条件（入力済みなら朝でも出せる）
    const oddsReasons = [];
    const minBestOdds = n("minBestOdds");
    const maxBestOdds = n("maxBestOdds");
    const bestOdds = Math.max(Number(o123)||0, Number(o132)||0);

    if (!bestOdds) oddsReasons.push("オッズ未入力");
    else {
      if (minBestOdds!=null && bestOdds<minBestOdds) oddsReasons.push("オッズ不足");
      if (maxBestOdds!=null && bestOdds>maxBestOdds) oddsReasons.push("オッズ上限超過");
    }

    // ③ 展示がまだなら、展示条件は後から（でも“分かる条件”は表示する）
    if (!r.exhReady) {
      const extra = oddsReasons.length ? ` / ${oddsReasons.join(" / ")}` : "";
      return { state:"WAIT", msg:`WAIT：展示（1〜3）待ち${extra}` };
    }

    // ④ 展示条件（previewsが来たら評価）
    const reasons = [];
    const maxTimeRank = n("maxTimeRank");
    const maxDelta2 = n("maxDelta2");
    const maxDelta3 = n("maxDelta3");
    const nearEpsV = n("nearEps") ?? 0.03;
    const maxNearCount = n("maxNearCount");

    const rank = exhibitionRank(r.exh);
    if (rank!=null && maxTimeRank!=null && rank>maxTimeRank) reasons.push("展示順位NG");

    // ★変更案：速い相手カウントは使わず、外枠が速いだけでNO
    const fasterL = fasterOppLanes(r.exh);
    const outerFast = fasterL.length>0 && fasterL.some(l=>l!==2 && l!==3);
    if (outerFast) reasons.push("外枠が速い");

    const d2 = deltaLane(r.exh, 2);
    if (d2!=null && maxDelta2!=null && d2 > maxDelta2) reasons.push("2号艇が遅い");

    const d3 = deltaLane(r.exh, 3);
    if (d3!=null && maxDelta3!=null && d3 > maxDelta3) reasons.push("3号艇が遅い");

    const nc = nearCount(r.exh, nearEpsV);
    if (nc!=null && maxNearCount!=null && nc > maxNearCount) reasons.push("混戦（1に近い艇が多い）");

    // odds理由も合流
    reasons.push(...oddsReasons.filter(x => x !== "オッズ未入力" ? true : true));

    if (reasons.length===0) {
      return { state:"BUY", msg:"BUY（条件OK）｜推奨：3連複 1-2-3（1点）", rank, outerFast, d2, d3, nc };
    }
    // オッズ未入力だけでNOにしたくない場合はここで調整可能（今はNOに含める設計）
    return { state:"NO", msg:`NO：${reasons.join(" / ")}`, rank, outerFast, d2, d3, nc };
  }

  // ===== 結果トップ3 =====
  function extractTop3(rr) {
    if (!rr || typeof rr !== "object") return null;
    const stack=[rr];
    while(stack.length){
      const cur=stack.pop();
      if(cur==null) continue;
      if(typeof cur==="string"){
        const m=cur.match(/\b([1-6])[-–]([1-6])[-–]([1-6])\b/);
        if(m) return `${m[1]}-${m[2]}-${m[3]}`;
      } else if(Array.isArray(cur)){
        for(const x of cur) stack.push(x);
      } else if(typeof cur==="object"){
        for(const k of Object.keys(cur)) stack.push(cur[k]);
      }
    }
    return null;
  }

  // ===== 払戻123 =====
  function normalizeComboDigits(s){
    const digits = String(s).match(/[1-6]/g);
    if (!digits || digits.length < 3) return "";
    return digits.slice(0,3).join("-");
  }

  function toNumberLoose(v){
    if (v == null) return null;
    if (typeof v === "object") v = v.value ?? v.amount ?? v.payout ?? v.pay ?? v.money ?? null;
    const s = String(v).replace(/,/g,"").trim();
    if (s === "") return null;
    const num = Number(s);
    return Number.isFinite(num) ? num : null;
  }

  function findPayoutInArray(arr, targetCombo){
    if(!Array.isArray(arr)) return null;
    const tgt = normalizeComboDigits(targetCombo);
    for(const it of arr){
      if(!it || typeof it!=="object") continue;
      const combo = it.combination ?? it.combo ?? it.kumi ?? it.kumiawase ?? it.pattern;
      const pay   = it.payout ?? it.pay ?? it.refund ?? it.amount ?? it.money ?? it.value;
      if(combo==null) continue;
      if(normalizeComboDigits(combo) === tgt){
        return toNumberLoose(pay);
      }
    }
    return null;
  }

  function extractPayout123(rr){
    const out={pay3t123:null,pay3f123:null};
    if(!rr || typeof rr!=="object") return out;

    const payouts = rr.payouts || rr.payout || rr.pay || rr.refunds || rr.refund || rr.haraimodoshi || rr.refund_list || rr.payout_list || null;

    const trifectaArr =
      (payouts && (payouts.trifecta || payouts.sanrentan || payouts["3t"] || payouts["3tan"])) ||
      rr.trifecta || rr.sanrentan || rr["3t"] || null;

    const trioArr =
      (payouts && (payouts.trio || payouts.sanrenpuku || payouts["3f"] || payouts["3fuku"])) ||
      rr.trio || rr.sanrenpuku || rr["3f"] || null;

    const hasTri  = Array.isArray(trifectaArr) && trifectaArr.length > 0;
    const hasTrio = Array.isArray(trioArr)     && trioArr.length > 0;

    const v3t = findPayoutInArray(trifectaArr, "1-2-3");
    const v3f = findPayoutInArray(trioArr,     "1-2-3");

    out.pay3t123 = (v3t == null && hasTri)  ? 0 : v3t;
    out.pay3f123 = (v3f == null && hasTrio) ? 0 : v3f;

    if (!Number.isFinite(out.pay3t123)) out.pay3t123 = null;
    if (!Number.isFinite(out.pay3f123)) out.pay3f123 = null;
    return out;
  }

  // ===== UI =====
  function renderVenueChecks() {
    const box = $("venueChecks");
    box.innerHTML="";
    const entries = Object.entries(VENUES).map(([k,v])=>({k:Number(k), v})).sort((a,b)=>a.k-b.k);
    for (const {k,v} of entries) {
      const el = document.createElement("label");
      el.className="cb";
      el.innerHTML = `<input type="checkbox" data-st="${k}"> ${k}:${v}`;
      const cb = el.querySelector("input");
      cb.checked = enabledStadiums.has(k);
      cb.addEventListener("change", ()=>{
        if (cb.checked) enabledStadiums.add(k); else enabledStadiums.delete(k);
        refresh();
      });
      box.appendChild(el);
    }
  }

  function renderSummary(races) {
    const total = races.length;
    const f1pass = races.filter(r => passFilter1(r).ok).length;
    let buy=0,no=0,wait=0,filtered=0,hasTop3=0,hasPay=0;
    for (const r of races) {
      const odds = getOdds(r.key);
      const st = judge(r, odds.o123, odds.o132).state;
      if (st==="BUY") buy++; else if (st==="NO") no++; else if (st==="WAIT") wait++; else filtered++;
      if (r.result_top3) hasTop3++;
      if (Number.isFinite(r.final_payout_3t_123) || Number.isFinite(r.final_payout_3f_123)) hasPay++;
    }
    $("summary").textContent =
      `取得${total}R / 条件①通過${f1pass}R / BUY${buy} / NO${no} / WAIT${wait} / 条件外${filtered} / 結果${hasTop3} / 払戻123${hasPay}`;
  }

  function makeRaceCard(r) {
    const odds = getOdds(r.key);
    const card = document.createElement("div");
    card.className = "raceCard";

    card.innerHTML = `
      <div class="row">
        <div>
          <span class="pill">${r.venue} ${r.race}R</span>
          <span class="badge b-wait" data-badge>WAIT</span>
          <span class="tag">${r.date}</span>
          <span class="tag">${r.title}</span>
          <span class="tag mono">prog:${r._progAt||"-"} exh:${r._exhAt||"-"} res:${r._resAt||"-"}</span>
        </div>
        <div class="muted">全国${r.nat2}% / 当地${r.loc2}% / M${r.motor2}%</div>
      </div>

      <div class="grid g2" style="margin-top:10px;">
        <div class="muted">
          展示 1:${Number.isFinite(r.exh["1"])?r.exh["1"]:"-"}
          2:${Number.isFinite(r.exh["2"])?r.exh["2"]:"-"}
          3:${Number.isFinite(r.exh["3"])?r.exh["3"]:"-"}
          4:${Number.isFinite(r.exh["4"])?r.exh["4"]:"-"}
          5:${Number.isFinite(r.exh["5"])?r.exh["5"]:"-"}
          6:${Number.isFinite(r.exh["6"])?r.exh["6"]:"-"}
          ${r.result_top3 ? `<div class="resultLine">結果（参考）: ${r.result_top3}</div>` : ``}
          <div class="resultLine">払戻123（100円/自動）: 3連単=${Number.isFinite(r.final_payout_3t_123)?r.final_payout_3t_123:"未取得"} / 3連複=${Number.isFinite(r.final_payout_3f_123)?r.final_payout_3f_123:"未取得"}</div>
        </div>
        <div>
          <div class="grid g2">
            <div><label>3連単 1-2-3（目安）</label><input data-o123 type="number" step="0.1"></div>
            <div><label>3連単 1-3-2（目安）</label><input data-o132 type="number" step="0.1"></div>
          </div>
          <div class="muted" style="margin-top:6px;">※BUY時の推奨は「3連複 1-2-3（1点）」</div>
        </div>
      </div>

      <div class="muted" style="margin-top:8px;" data-msg>…</div>
    `;

    const inp123 = card.querySelector("[data-o123]");
    const inp132 = card.querySelector("[data-o132]");
    const badge = card.querySelector("[data-badge]");
    const msg = card.querySelector("[data-msg]");

    inp123.value = odds.o123 ?? "";
    inp132.value = odds.o132 ?? "";

    function update() {
      setOdds(r.key, inp123.value, inp132.value);
      const st = judge(r, inp123.value, inp132.value);

      if (st.state==="BUY") { badge.textContent="BUY"; badge.className="badge b-buy"; }
      else if (st.state==="NO") { badge.textContent="NO"; badge.className="badge b-no"; }
      else if (st.state==="WAIT") { badge.textContent="WAIT"; badge.className="badge b-wait"; }
      else { badge.textContent="条件外"; badge.className="badge b-filter"; }

      msg.textContent = st.msg;
    }

    inp123.addEventListener("input", update);
    inp132.addEventListener("input", update);
    update();
    return card;
  }

  // 0件対策込み
  function renderList(races) {
    const mode = $("viewMode").value;
    let show = races.slice();
    if (mode === "candidates") show = show.filter(r => passFilter1(r).ok);

    const list = $("list");
    list.innerHTML = "";

    if (show.length === 0) {
      const box = document.createElement("div");
      box.className = "muted";
      box.style.padding = "10px";
      box.innerHTML = `
        表示できるレースがありません。<br/>
        ・候補のみ：条件①通過が0件の可能性<br/>
        ・取得失敗：右上ステータスを確認<br/>
        <div style="margin-top:8px;">
          <button class="btn2" id="toAllBtn">全件表示に切り替える</button>
        </div>
      `;
      list.appendChild(box);
      box.querySelector("#toAllBtn").addEventListener("click", () => {
        $("viewMode").value = "all";
        renderList(LAST_RACES);
      });
      return;
    }

    function stateRank(r) {
      const odds = getOdds(r.key);
      const st = judge(r, odds.o123, odds.o132).state;
      if (st==="BUY") return 0;
      if (st==="WAIT") return 1;
      if (st==="NO") return 2;
      return 3;
    }
    show.sort((a,b) => (stateRank(a)-stateRank(b)) || a.venue.localeCompare(b.venue) || a.race-b.race);

    for (const r of show) list.appendChild(makeRaceCard(r));
  }

  // ===== 送信 =====
  async function postToSheet(payload) {
    const body = JSON.stringify(payload);
    try {
      const res = await fetch(GAS_URL, { method:"POST", headers:{ "Content-Type":"application/json" }, body });
      const text = await res.text();
      return { ok:true, mode:"cors", text };
    } catch (e) {
      try {
        await fetch(GAS_URL, { method:"POST", mode:"no-cors", headers:{ "Content-Type":"text/plain;charset=utf-8" }, body });
        return { ok:true, mode:"no-cors", text:"(no-cors)" };
      } catch (e2) {
        return { ok:false, mode:"fail", text:String(e2) };
      }
    }
  }

  function makeSheetRow(r, st) {
    const odds = getOdds(r.key);
    const outerFast = r.exhReady ? (fasterOppLanes(r.exh).some(l=>l!==2 && l!==3)) : "";
    const rank1 = r.exhReady ? (exhibitionRank(r.exh) ?? "") : "";

    return {
      date: r.date,
      venue: r.venue,
      race: r.race,
      status: st.state,
      nat2: r.nat2,
      loc2: r.loc2,
      motor2: r.motor2,
      exh_rank_1: rank1,
      fast_opp_count: "", // 互換のため残す（判定は使わない）
      outer_fast: outerFast,
      odds_input_3t_123: odds.o123,
      odds_input_3t_132: odds.o132,
      final_odds_3t_123: "",
      final_odds_3f_123: "",
      final_payout_3t_123: (Number.isFinite(r.final_payout_3t_123) ? r.final_payout_3t_123 : ""),
      final_payout_3f_123: (Number.isFinite(r.final_payout_3f_123) ? r.final_payout_3f_123 : ""),
      result_top3: (r.result_top3 ? ("'" + r.result_top3) : "")
    };
  }

  async function sendRows(rows) {
    clearSendLog();
    setSendStatus(`送信中… ${rows.length}件`);
    logSend(`GAS_URL: ${GAS_URL}`);
    let ok=0, ng=0;
    for (let i=0; i<rows.length; i++) {
      const payload = rows[i];
      logSend(`POST ${i+1}/${rows.length}: ${payload.date} ${payload.venue} ${payload.race}R ${payload.status}`);
      const r = await postToSheet(payload);
      if (r.ok) { ok++; logSend(`  -> OK (${r.mode}) ${String(r.text).slice(0,80)}`); }
      else { ng++; logSend(`  -> NG ${r.text}`); }
      setSendStatus(`送信中… ${i+1}/${rows.length}（OK${ok}/NG${ng}）`);
      await new Promise(res => setTimeout(res, 150));
    }
    setSendStatus(`完了：${rows.length}件（OK${ok}/NG${ng}）`);
  }

  async function handleSendBuyOnly() {
    if (!LAST_RACES.length) { alert("まず更新してください"); return; }
    const rows = [];
    for (const r of LAST_RACES) {
      if (!passFilter1(r).ok) continue;
      const odds = getOdds(r.key);
      const st = judge(r, odds.o123, odds.o132);
      if (st.state === "BUY") rows.push(makeSheetRow(r, st));
    }
    if (!rows.length) { setSendStatus("BUYが0件なので送信なし"); return; }
    if (!confirm(`BUYのみ ${rows.length}件を送信します。OK？`)) return;
    await sendRows(rows);
  }

  async function handleSendCandidates() {
    if (!LAST_RACES.length) { alert("まず更新してください"); return; }
    const rows = [];
    for (const r of LAST_RACES) {
      if (!passFilter1(r).ok) continue;
      const odds = getOdds(r.key);
      const st = judge(r, odds.o123, odds.o132);
      rows.push(makeSheetRow(r, st));
    }
    if (!rows.length) { setSendStatus("条件①通過が0件なので送信なし"); return; }
    if (!confirm(`候補（条件①通過） ${rows.length}件を送信します。OK？`)) return;
    await sendRows(rows);
  }

  async function handleSendTest() {
    clearSendLog();
    const payload = { date:new Date().toISOString().slice(0,10), venue:"TEST", race:0, status:"TEST" };
    setSendStatus("テスト送信中…");
    logSend(JSON.stringify(payload));
    const r = await postToSheet(payload);
    if (r.ok) { setSendStatus(`テスト送信 OK（${r.mode}）`); alert("TEST行がMasterに増えたか確認してください"); }
    else { setSendStatus("テスト送信 NG"); alert("失敗：ログ確認"); }
  }

  // ===== 段階ロード =====
  function buildBaseRaces(programsJson, progAtStr) {
    const progList = programsJson.programs || [];
    const races = [];
    for (const pr of progList) {
      const stadium = pr.race_stadium_number;
      if (!enabledStadiums.has(stadium)) continue;

      const key = `${pr.race_date}-${stadium}-${pr.race_number}`;
      const b1 = (pr.boats || []).find(b=>b.racer_boat_number===1);
      if (!b1) continue;

      races.push({
        key,
        venue: VENUES[stadium],
        race: pr.race_number,
        date: pr.race_date,
        title: pr.race_title || "一般戦",
        nat2: Number(b1.racer_national_top_2_percent ?? 0),
        loc2: Number(b1.racer_local_top_2_percent ?? 0),
        motor2: Number(b1.racer_assigned_motor_top_2_percent ?? 0),
        exh: {},
        exhReady: false,
        result_top3: null,
        final_payout_3t_123: null,
        final_payout_3f_123: null,
        _progAt: progAtStr,
        _exhAt: "-",
        _resAt: "-"
      });
    }
    return races;
  }

  function mergePreviews(races, previewsJson, exhAtStr) {
    const prevList = previewsJson.previews || [];
    const prevMap = new Map();
    for (const p of prevList) {
      const key = `${p.race_date}-${p.race_stadium_number}-${p.race_number}`;
      prevMap.set(key, p);
    }

    for (const r of races) {
      const parts = r.key.split("-");
      const date = parts.slice(0,3).join("-");
      const stadium = Number(parts[3]);
      const raceNo = Number(parts[4]);
      const pv = prevMap.get(`${date}-${stadium}-${raceNo}`);
      if (!pv || !pv.boats) continue;

      const exh = {};
      for (let lane=1; lane<=6; lane++) {
        const obj = pv.boats[String(lane)] || pv.boats[lane] || null;
        const t = obj?.racer_exhibition_time ?? obj?.exhibition_time ?? null;
        if (t!=null) exh[String(lane)] = Number(t);
      }
      r.exh = exh;
      r.exhReady = exhReady(exh);
      r._exhAt = exhAtStr;
    }
  }

  function mergeResults(races, resultsJson, resAtStr) {
    const list = resultsJson.results || resultsJson.races || [];
    const map = new Map();
    for (const rr of list) {
      const key = `${rr.race_date}-${rr.race_stadium_number}-${rr.race_number}`;
      map.set(key, rr);
    }

    for (const r of races) {
      const parts = r.key.split("-");
      const date = parts.slice(0,3).join("-");
      const stadium = Number(parts[3]);
      const raceNo = Number(parts[4]);
      const rr = map.get(`${date}-${stadium}-${raceNo}`);
      if (!rr) continue;

      r.result_top3 = extractTop3(rr);
      const pay = extractPayout123(rr);
      r.final_payout_3t_123 = pay.pay3t123;
      r.final_payout_3f_123 = pay.pay3f123;
      r._resAt = resAtStr;
    }
  }

  // auto refresh
  let AUTO_TIMER = null;
  function clearAutoTimer() { if (AUTO_TIMER) { clearTimeout(AUTO_TIMER); AUTO_TIMER = null; } }
  function maybeScheduleAutoRefresh() {
    clearAutoTimer();
    if (!$("autoRefresh").checked) { setAutoStatus("自動更新OFF"); return; }
    const need = LAST_RACES.some(r => passFilter1(r).ok && !r.exhReady);
    if (!need) { setAutoStatus("展示OK"); return; }
    setAutoStatus("展示待ち→20秒後に自動更新");
    AUTO_TIMER = setTimeout(refresh, 20000);
  }

  async function refresh() {
    try {
      setStatus("programs取得中…");
      const progAt = nowTimeStr();
      const programs = await fetchJson(PROGRAMS_URL);

      // ① programsだけで即表示
      LAST_RACES = buildBaseRaces(programs, progAt);
      renderSummary(LAST_RACES);
      renderList(LAST_RACES);
      setStatus(`programs OK（${LAST_RACES.length}R）/ ${progAt} / previews&results取得中…`);

      // ② previews/results を並行で取り、来た順に反映
      const previewsP = fetchJson(PREVIEWS_URL).then(pv => {
        mergePreviews(LAST_RACES, pv, nowTimeStr());
        renderSummary(LAST_RACES);
        renderList(LAST_RACES);
        setStatus(`previews反映 / ${nowTimeStr()} / results取得中…`);
      }).catch(e => {
        logSend("previews失敗: " + String(e));
      });

      const resultsP = fetchJson(RESULTS_URL).then(rs => {
        mergeResults(LAST_RACES, rs, nowTimeStr());
        renderSummary(LAST_RACES);
        renderList(LAST_RACES);
        setStatus(`results反映 / ${nowTimeStr()} / 完了`);
      }).catch(e => {
        logSend("results失敗: " + String(e));
      });

      await Promise.allSettled([previewsP, resultsP]);
      setSendStatus("準備OK");
      logSend("更新完了");
      maybeScheduleAutoRefresh();
    } catch (e) {
      setStatus("取得失敗");
      setAutoStatus("-");
      setSendStatus("送信不可（取得失敗）");
      logSend("取得失敗: " + String(e));
    }
  }

  // wiring
  $("refreshBtn").addEventListener("click", refresh);
  $("applyBtn").addEventListener("click", () => renderList(LAST_RACES));
  $("sendBuyBtn").addEventListener("click", handleSendBuyOnly);
  $("sendCandBtn").addEventListener("click", handleSendCandidates);
  $("sendTestBtn").addEventListener("click", handleSendTest);
  $("clearLocalBtn").addEventListener("click", () => { if(confirm("オッズ保存を全消去しますか？")){ clearOddsAll(); refresh(); } });
  $("autoRefresh").addEventListener("change", maybeScheduleAutoRefresh);

  // init
  renderVenueChecks();
  refresh();
})();
</script>
</body>
</html>
