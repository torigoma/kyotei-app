<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>競艇 v2（Worker連携：①3連単/②3連複 自動切替）</title>
  <style>
    body { font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; margin:0; background:#0b0f14; color:#e9eef5; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    h1 { font-size: 18px; margin: 8px 0 10px; }
    .sub { font-size: 12px; color:#b8c5d6; margin-bottom: 10px; line-height:1.6; }

    .card { background:#121a24; border:1px solid #1c2a3b; border-radius:14px; padding:14px; margin:10px 0; box-shadow:0 6px 18px rgba(0,0,0,.25); }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid #2a3e5b; background:#0d141d; color:#cfe3ff; }

    .grid { display:grid; gap:10px; }
    .g2 { grid-template-columns: 1fr 1fr; }
    .g3 { grid-template-columns: 1fr 1fr 1fr; }
    @media (max-width: 760px) { .g2,.g3 { grid-template-columns: 1fr; } }

    label { font-size:12px; color:#b8c5d6; display:block; margin-bottom:6px; }
    input, select { width:100%; padding:10px; border-radius:10px; border:1px solid #223248; background:#0d141d; color:#e9eef5; font-size:14px; box-sizing:border-box; }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .rowL { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .btn { background:#2b6ff7; border:0; color:#fff; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; }
    .btn2 { background:#223248; border:1px solid #2a3e5b; color:#e9eef5; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; }
    .btnDanger { background:#7f1d1d; border:1px solid #991b1b; color:#fff; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; }

    .muted { color:#b8c5d6; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    .hr { height:1px; background:#223248; margin:12px 0; }

    .badge { display:inline-block; padding:3px 10px; border-radius:999px; font-size:12px; font-weight:900; border:1px solid #2a3e5b; background:#0d141d; }
    .b-buy { color:#6ee7b7; }
    .b-no { color:#fca5a5; }
    .b-wait { color:#ffd27d; }
    .b-filter { color:#8aa3c7; }

    .raceCard { background:#111a26; border:1px solid #1c2a3b; border-radius:14px; padding:12px; margin:10px 0; }
    .tag { display:inline-block; padding:2px 8px; border:1px solid #2a3e5b; border-radius:999px; font-size:11px; margin-left:8px; color:#b8c5d6; }
    .resultLine { margin-top:6px; color:#b8c5d6; }

    .checkboxes { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .cb { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3e5b; border-radius:999px; background:#0d141d; font-size:12px; color:#e9eef5; }
    .cb input { width:auto; }

    .log { white-space: pre-wrap; background:#0d141d; border:1px solid #223248; border-radius:10px; padding:10px; max-height:160px; overflow:auto; font-size:12px; }
    .small { font-size: 11px; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>競艇 v2（Worker連携：①3連単/②3連複 自動切替）</h1>
  <div class="sub">
    ✅ ①=3連単 / ②=3連複 を展示で自動切替（1レース1点）。<br/>
    ✅ オッズ/風波/STは Worker で自動取得（最終候補だけ）→ 手入力は最終候補だけ出る。<br/>
    ✅ 自動更新は previews/results のみ（programsは固定でブレにくい）。<br/>
    ✅ スナップショット保存（JSON/CSV）で日々の分析用データを蓄積できます（送信ボタンは廃止）。
  </div>

  <div class="card">
    <div class="pill">条件</div>

    <div class="grid g3" style="margin-top:10px;">
      <div><label>全国2連率(%) 下限</label><input id="minNat2" type="number" step="0.1" value="42" /></div>
      <div><label>当地2連率(%) 下限</label><input id="minLoc2" type="number" step="0.1" value="42" /></div>
      <div><label>モーター2連率(%) 下限</label><input id="minMotor2" type="number" step="0.1" value="40" /></div>
    </div>

    <div class="grid g3" style="margin-top:10px;">
      <div><label>展示：1号艇順位（上位）</label><input id="maxTimeRank" type="number" step="1" value="2" /></div>
      <div><label>混戦回避：近い艇の上限数</label><input id="maxNearCount" type="number" step="1" value="2" /></div>
      <div><label>混戦判定：1号艇 +（秒）以内</label><input id="nearEps" type="number" step="0.01" value="0.03" /></div>
    </div>

    <div class="grid g3" style="margin-top:10px;">
      <div><label>Δ2（2−1）上限</label><input id="maxDelta2" type="number" step="0.01" value="0.12" /></div>
      <div><label>Δ3（3−1）上限</label><input id="maxDelta3" type="number" step="0.01" value="0.15" /></div>
      <div><label>①(3T)判定：2-3の差（秒）</label><input id="min23Gap" type="number" step="0.01" value="0.03" /></div>
    </div>

    <div class="hr"></div>

    <div class="pill">オッズフィルタ（任意）</div>
    <div class="grid g2" style="margin-top:10px;">
      <label class="cb" style="margin:0;">
        <input type="checkbox" id="oddsFilterOn" checked />
        オッズで足切りする（利益重視）
      </label>
      <div class="muted small" style="align-self:center;">※ONだと低すぎ/高すぎはBUYしない</div>
    </div>

    <div class="grid g3" style="margin-top:10px;">
      <div><label>① 3連単 min</label><input id="minOdds3t" type="number" step="0.1" value="8.0" /></div>
      <div><label>① 3連単 max</label><input id="maxOdds3t" type="number" step="0.1" value="80" /></div>
      <div><label>② 3連複 min</label><input id="minOdds3f" type="number" step="0.1" value="2.0" /></div>
    </div>
    <div class="grid g3" style="margin-top:10px;">
      <div><label>② 3連複 max</label><input id="maxOdds3f" type="number" step="0.1" value="30" /></div>
      <div class="muted small" style="align-self:center;">②は低オッズでも勝てる可能性があるので minは低め推奨</div>
      <div></div>
    </div>

    <div class="hr"></div>

    <div class="pill">集計</div>
    <div class="muted" style="margin-top:8px;" id="summary">-</div>

    <div class="hr"></div>

    <div class="pill">表示モード</div>
    <div class="grid g2" style="margin-top:10px;">
      <div>
        <label>表示</label>
        <select id="viewMode">
          <option value="candidates">候補のみ（条件①通過）</option>
          <option value="all" selected>全件表示（理由確認用）</option>
        </select>
      </div>
      <div style="align-self:end;">
        <button class="btn2" id="applyBtn">適用</button>
      </div>
    </div>

    <div class="hr"></div>

    <div class="pill">対象レース場（全場ON）</div>
    <div class="checkboxes" id="venueChecks"></div>

    <div class="hr"></div>

    <div class="pill">データ保存（分析用スナップショット）</div>
    <div class="row" style="margin-top:10px;">
      <div class="rowL">
        <button class="btn" id="exportJsonBtn">保存：JSON</button>
        <button class="btn2" id="exportCsvBtn">保存：CSV</button>
        <button class="btnDanger" id="clearLocalBtn">オッズ手入力を全消去</button>
      </div>
      <div class="muted mono" id="exportStatus">-</div>
    </div>
    <div class="muted small" style="margin-top:8px;">
      ※ その時点の全レース（候補/理由/最終買い目/オッズ/展示/払戻など）を保存します。日々の分析はこのファイルを蓄積してください。
    </div>

    <div class="hr"></div>

    <div class="row">
      <div class="rowL">
        <button class="btn" id="refreshBtn">更新（programs更新）</button>
        <label class="cb" style="margin:0;">
          <input type="checkbox" id="autoRefresh" checked />
          自動更新（20秒：previews/resultsのみ）
        </label>
      </div>
      <div class="muted mono">
        <span id="status">-</span> / <span id="autoStatus">-</span>
      </div>
    </div>

    <div class="muted small" style="margin-top:10px;">
      Worker: <span class="mono" id="workerBase"></span>
    </div>
  </div>

  <div class="card">
    <div class="pill">レース一覧</div>
    <div id="list"></div>
  </div>
</div>

<script>
(() => {
  // ====== CONFIG ======
  const WORKER_BASE = "https://kyotei-worker.tanabedaichi0831.workers.dev";

  document.getElementById("workerBase").textContent = WORKER_BASE;

  const $ = (id) => document.getElementById(id);
  const num = (id) => {
    const el = $(id);
    if (!el) return null;
    const v = el.value;
    if (v === "" || v == null) return null;
    const x = Number(v);
    return Number.isFinite(x) ? x : null;
  };

  const VENUES = {
    1:"桐生",2:"戸田",3:"江戸川",4:"平和島",5:"多摩川",6:"浜名湖",7:"蒲郡",8:"常滑",
    9:"津",10:"三国",11:"びわこ",12:"住之江",13:"尼崎",14:"鳴門",15:"丸亀",16:"児島",
    17:"宮島",18:"徳山",19:"下関",20:"若松",21:"芦屋",22:"福岡",23:"唐津",24:"大村"
  };

  let enabledStadiums = new Set(Array.from({length:24}, (_,i)=>i+1));
  let LAST_RACES = [];
  let LAST_PROGRAMS_SNAPSHOT = null; // programs固定用

  // manual odds cache (final candidates only UI, but stored anyway)
  const ODDS_KEY = "kyotei_odds_manual_v2";
  function loadOddsCache() { try { return JSON.parse(localStorage.getItem(ODDS_KEY) || "{}"); } catch { return {}; } }
  function saveOddsCache(cache) { try { localStorage.setItem(ODDS_KEY, JSON.stringify(cache)); } catch {} }
  function getManualOdds(key) {
    const c = loadOddsCache();
    return c[key] || { o3t123:"", o3t132:"", o3f123:"" };
  }
  function setManualOdds(key, patch) {
    const c = loadOddsCache();
    c[key] = { ...(c[key]||{o3t123:"",o3t132:"",o3f123:""}), ...patch };
    saveOddsCache(c);
  }
  function clearManualOddsAll() { try { localStorage.removeItem(ODDS_KEY); } catch {} }

  // in-memory caches to avoid re-fetch
  const ODDS_AUTO = new Map();      // key -> { odds3t, odds3f, scraped_at }
  const BEFORE_AUTO = new Map();    // key -> { info, scraped_at }

  function setStatus(msg){ $("status").textContent = msg; }
  function setAutoStatus(msg){ $("autoStatus").textContent = msg; }
  function setExportStatus(msg){ $("exportStatus").textContent = msg; }

  function ymdToHd(ymd){
    return String(ymd || "").replace(/-/g,"");
  }

  async function fetchJson(url){
    const res = await fetch(url, { cache:"no-store" });
    if(!res.ok) throw new Error(`fetch failed ${res.status}: ${url}`);
    return await res.json();
  }

  async function fetchTodayBundle(){
    return await fetchJson(`${WORKER_BASE}/api/today?v=${Date.now()}`);
  }

  async function ensureOddsAuto(r){
    const key = r.key;
    if (ODDS_AUTO.has(key)) return ODDS_AUTO.get(key);
    const hd = ymdToHd(r.date);
    const url = `${WORKER_BASE}/api/odds?hd=${hd}&jcd=${r.stadium}&rno=${r.race}&v=${Date.now()}`;
    const js = await fetchJson(url);
    if (js && js.ok) {
      ODDS_AUTO.set(key, js);
      return js;
    }
    return null;
  }

  async function ensureBeforeAuto(r){
    const key = r.key;
    if (BEFORE_AUTO.has(key)) return BEFORE_AUTO.get(key);
    const hd = ymdToHd(r.date);
    const url = `${WORKER_BASE}/api/beforeinfo?hd=${hd}&jcd=${r.stadium}&rno=${r.race}&v=${Date.now()}`;
    const js = await fetchJson(url);
    if (js && js.ok) {
      BEFORE_AUTO.set(key, js);
      return js;
    }
    return null;
  }

  // ----- base metrics -----
  function exhReady(exh){
    for(let lane=1; lane<=3; lane++){
      const t = Number(exh[String(lane)]);
      if(!Number.isFinite(t) || t<=0) return false;
    }
    return true;
  }

  function passFilter1(r){
    const minNat2 = num("minNat2");
    const minLoc2 = num("minLoc2");
    const minMotor2 = num("minMotor2");
    const reasons=[];
    if(minNat2!=null && r.nat2 < minNat2) reasons.push("全国2連率不足");
    if(minLoc2!=null && r.loc2 < minLoc2) reasons.push("当地2連率不足");
    if(minMotor2!=null && r.motor2 < minMotor2) reasons.push("モーター2連率不足");
    return { ok: reasons.length===0, reasons };
  }

  function exhibitionRank(exh){
    const arr = Object.entries(exh)
      .map(([lane,t])=>({lane:Number(lane), t:Number(t)}))
      .filter(x=>Number.isFinite(x.lane) && Number.isFinite(x.t) && x.t>0)
      .sort((a,b)=>a.t-b.t);
    const idx = arr.findIndex(x=>x.lane===1);
    return idx>=0 ? idx+1 : null;
  }

  function fasterOppLanes(exh){
    const t1 = Number(exh["1"]);
    if(!Number.isFinite(t1) || t1<=0) return [];
    const lanes=[];
    for(let lane=2; lane<=6; lane++){
      const t = Number(exh[String(lane)]);
      if(Number.isFinite(t) && t>0 && t < t1) lanes.push(lane);
    }
    return lanes;
  }

  function deltaLane(exh, lane){
    const t1 = Number(exh["1"]);
    const tx = Number(exh[String(lane)]);
    if(!Number.isFinite(t1) || !Number.isFinite(tx) || t1<=0 || tx<=0) return null;
    return tx - t1;
  }

  function nearCount(exh, eps){
    const t1 = Number(exh["1"]);
    if(!Number.isFinite(t1) || t1<=0 || !Number.isFinite(eps)) return null;
    let c=0;
    for(let lane=2; lane<=6; lane++){
      const t = Number(exh[String(lane)]);
      if(!Number.isFinite(t) || t<=0) continue;
      if(t <= t1 + eps) c++;
    }
    return c;
  }

  // ①/② plan
  function computePlan(r){
    const f1 = passFilter1(r);
    if(!f1.ok) return { level:"out", reasons:f1.reasons };

    if(!r.exhReady) return { level:"wait", reasons:["展示待ち"] };

    const reasons=[];
    const rank = exhibitionRank(r.exh);
    const maxTimeRank = num("maxTimeRank");
    if(rank!=null && maxTimeRank!=null && rank>maxTimeRank) reasons.push("展示順位NG");

    const fasterL = fasterOppLanes(r.exh);
    const outerFast = fasterL.length>0 && fasterL.some(l=>l!==2 && l!==3);
    if(outerFast) reasons.push("外枠が速い");

    const d2 = deltaLane(r.exh,2);
    const d3 = deltaLane(r.exh,3);
    const maxDelta2 = num("maxDelta2");
    const maxDelta3 = num("maxDelta3");
    if(d2!=null && maxDelta2!=null && d2>maxDelta2) reasons.push("2号艇が遅い");
    if(d3!=null && maxDelta3!=null && d3>maxDelta3) reasons.push("3号艇が遅い");

    const eps = num("nearEps") ?? 0.03;
    const nc = nearCount(r.exh, eps);
    const maxNearCount = num("maxNearCount");
    if(nc!=null && maxNearCount!=null && nc>maxNearCount) reasons.push("混戦（1に近い艇が多い）");

    if(reasons.length){
      return { level:"no", reasons, rank, outerFast, d2, d3, nc };
    }

    // final candidate -> decide 3T or 3F
    const e2 = Number(r.exh["2"]);
    const e3 = Number(r.exh["3"]);
    const min23Gap = num("min23Gap") ?? 0.03;
    const gap = (Number.isFinite(e2) && Number.isFinite(e3)) ? Math.abs(e2-e3) : 0;

    let betType = "3F";
    let combo = "1-2-3";

    // ① (3T) if order looks stable: 1 is fastest AND 2-3 gap big enough
    if(rank === 1 && gap >= min23Gap){
      betType = "3T";
      combo = (e2 < e3) ? "1-2-3" : "1-3-2";
    }

    return { level:"final", betType, combo, rank, outerFast, d2, d3, nc };
  }

  function getAutoOddsFor(r, betType, combo){
    const ao = ODDS_AUTO.get(r.key);
    if(!ao) return null;
    if(betType==="3T") return ao.odds3t ? ao.odds3t[combo] : null;
    if(betType==="3F") return ao.odds3f ? ao.odds3f[combo] : null;
    return null;
  }

  function getManualOddFor(r, betType, combo){
    const m = getManualOdds(r.key);
    const v = (betType==="3T")
      ? (combo==="1-2-3" ? m.o3t123 : combo==="1-3-2" ? m.o3t132 : "")
      : (betType==="3F" ? m.o3f123 : "");
    const numv = Number(v);
    return Number.isFinite(numv) && numv>0 ? numv : null;
  }

  function getOddFor(r, betType, combo){
    return getManualOddFor(r, betType, combo) ?? getAutoOddsFor(r, betType, combo);
  }

  function getOddWithSource(r, betType, combo){
    const manual = getManualOddFor(r, betType, combo);
    if (manual != null) return { odd: manual, source: "manual" };
    const auto = getAutoOddsFor(r, betType, combo);
    if (auto != null) return { odd: auto, source: "auto" };
    return { odd: null, source: "none" };
  }

  function oddsPass(betType, odd){
    if(!$("oddsFilterOn").checked) return { ok:true, reasons:[] };
    const reasons=[];
    if(!Number.isFinite(odd) || odd<=0) return { ok:false, reasons:["オッズ未取得/未入力"] };

    if(betType==="3T"){
      const mn = num("minOdds3t"); const mx = num("maxOdds3t");
      if(mn!=null && odd<mn) reasons.push("3連単オッズ低すぎ");
      if(mx!=null && odd>mx) reasons.push("3連単オッズ高すぎ");
    } else {
      const mn = num("minOdds3f"); const mx = num("maxOdds3f");
      if(mn!=null && odd<mn) reasons.push("3連複オッズ低すぎ");
      if(mx!=null && odd>mx) reasons.push("3連複オッズ高すぎ");
    }
    return { ok: reasons.length===0, reasons };
  }

  function evaluate(r){
    const f1 = passFilter1(r);
    if(!f1.ok) return { state:"条件外", msg:`条件外：${f1.reasons.join(" / ")}` };

    const plan = computePlan(r);
    if(plan.level==="wait") return { state:"WAIT", msg:"WAIT：展示（1〜3）待ち", plan };
    if(plan.level==="no") return { state:"NO", msg:`NO：${plan.reasons.join(" / ")}`, plan };
    if(plan.level==="out") return { state:"条件外", msg:`条件外：${plan.reasons.join(" / ")}`, plan };

    // final
    const { odd, source } = getOddWithSource(r, plan.betType, plan.combo);
    const op = oddsPass(plan.betType, odd);

    if(!op.ok){
      if(op.reasons.includes("オッズ未取得/未入力")) {
        return { state:"WAIT", msg:`WAIT：オッズ取得/入力待ち（${plan.betType} ${plan.combo}）`, plan, odd, odd_source: source };
      }
      return { state:"NO", msg:`NO：${op.reasons.join(" / ")}`, plan, odd, odd_source: source };
    }

    return { state:"BUY", msg:`BUY：${plan.betType} ${plan.combo}（1点）`, plan, odd, odd_source: source };
  }

  // ----- results helpers -----
  function extractTop3(rr){
    if (!rr || typeof rr !== "object") return null;
    const stack=[rr];
    while(stack.length){
      const cur=stack.pop();
      if(cur==null) continue;
      if(typeof cur==="string"){
        const m=cur.match(/\b([1-6])[-–]([1-6])[-–]([1-6])\b/);
        if(m) return `${m[1]}-${m[2]}-${m[3]}`;
      } else if(Array.isArray(cur)){
        for(const x of cur) stack.push(x);
      } else if(typeof cur==="object"){
        for(const k of Object.keys(cur)) stack.push(cur[k]);
      }
    }
    return null;
  }

  function normalizeComboDigits(s){
    const digits = String(s).match(/[1-6]/g);
    if (!digits || digits.length < 3) return "";
    return digits.slice(0,3).join("-");
  }
  function toNumberLoose(v){
    if (v == null) return null;
    if (typeof v === "object") v = v.value ?? v.amount ?? v.payout ?? v.pay ?? v.money ?? null;
    const s = String(v).replace(/,/g,"").trim();
    if (s === "") return null;
    const numv = Number(s);
    return Number.isFinite(numv) ? numv : null;
  }
  function findPayoutInArray(arr, targetCombo){
    if(!Array.isArray(arr)) return null;
    const tgt = normalizeComboDigits(targetCombo);
    for(const it of arr){
      if(!it || typeof it!=="object") continue;
      const combo = it.combination ?? it.combo ?? it.kumi ?? it.kumiawase ?? it.pattern;
      const pay   = it.payout ?? it.pay ?? it.refund ?? it.amount ?? it.money ?? it.value;
      if(combo==null) continue;
      if(normalizeComboDigits(combo) === tgt){
        return toNumberLoose(pay);
      }
    }
    return null;
  }
  function extractPayout123(rr){
    const out={pay3t123:null,pay3f123:null};
    if(!rr || typeof rr!=="object") return out;

    const payouts = rr.payouts || rr.payout || rr.pay || rr.refunds || rr.refund || rr.haraimodoshi || rr.refund_list || rr.payout_list || null;

    const trifectaArr =
      (payouts && (payouts.trifecta || payouts.sanrentan || payouts["3t"] || payouts["3tan"])) ||
      rr.trifecta || rr.sanrentan || rr["3t"] || null;

    const trioArr =
      (payouts && (payouts.trio || payouts.sanrenpuku || payouts["3f"] || payouts["3fuku"])) ||
      rr.trio || rr.sanrenpuku || rr["3f"] || null;

    const hasTri  = Array.isArray(trifectaArr) && trifectaArr.length > 0;
    const hasTrio = Array.isArray(trioArr)     && trioArr.length > 0;

    const v3t = findPayoutInArray(trifectaArr, "1-2-3");
    const v3f = findPayoutInArray(trioArr,     "1-2-3");

    out.pay3t123 = (v3t == null && hasTri)  ? 0 : v3t;
    out.pay3f123 = (v3f == null && hasTrio) ? 0 : v3f;

    if (!Number.isFinite(out.pay3t123)) out.pay3t123 = null;
    if (!Number.isFinite(out.pay3f123)) out.pay3f123 = null;
    return out;
  }

  function renderVenueChecks(){
    const box = $("venueChecks");
    box.innerHTML="";
    const entries = Object.entries(VENUES).map(([k,v])=>({k:Number(k), v})).sort((a,b)=>a.k-b.k);
    for(const {k,v} of entries){
      const el = document.createElement("label");
      el.className="cb";
      el.innerHTML = `<input type="checkbox" data-st="${k}"> ${k}:${v}`;
      const cb = el.querySelector("input");
      cb.checked = enabledStadiums.has(k);
      cb.addEventListener("change", ()=>{
        if(cb.checked) enabledStadiums.add(k); else enabledStadiums.delete(k);
        refreshFull();
      });
      box.appendChild(el);
    }
  }

  function renderSummary(races){
    const total = races.length;
    const f1pass = races.filter(r => passFilter1(r).ok).length;
    let buy=0,no=0,wait=0,filtered=0,finals=0,oddsReady=0,beforeReady=0;
    for(const r of races){
      const ev = evaluate(r);
      if(ev.plan && ev.plan.level==="final") finals++;
      if(ev.state==="BUY") buy++;
      else if(ev.state==="NO") no++;
      else if(ev.state==="WAIT") wait++;
      else filtered++;
      if(ODDS_AUTO.has(r.key)) oddsReady++;
      if(BEFORE_AUTO.has(r.key)) beforeReady++;
    }
    $("summary").textContent =
      `取得${total}R / 条件①通過${f1pass}R / 最終候補${finals} / BUY${buy} / NO${no} / WAIT${wait} / 条件外${filtered} / odds${oddsReady} / before${beforeReady}`;
  }

  function dispTime(v){
    const x = Number(v);
    if(!Number.isFinite(x) || x<=0) return "-";
    return String(x);
  }

  function makeRaceCard(r){
    const ev = evaluate(r);
    const manual = getManualOdds(r.key);

    const card = document.createElement("div");
    card.className = "raceCard";

    const badgeClass =
      ev.state==="BUY" ? "badge b-buy" :
      ev.state==="NO" ? "badge b-no" :
      ev.state==="WAIT" ? "badge b-wait" : "badge b-filter";

    const plan = ev.plan;
    const isFinal = plan && plan.level==="final";
    const autoOdds = ODDS_AUTO.get(r.key);
    const autoBefore = BEFORE_AUTO.get(r.key);

    const oddsBlock = isFinal ? `
      <div class="hr"></div>
      <div class="muted small">
        <b>最終候補</b>：${plan.betType} ${plan.combo}（1点）
        ${autoOdds ? `<span class="tag mono">odds@${autoOdds.scraped_at?.slice(11,19) || "-"}</span>` : `<span class="tag">odds未取得</span>`}
        ${autoBefore ? `<span class="tag mono">before@${autoBefore.scraped_at?.slice(11,19) || "-"}</span>` : `<span class="tag">before未取得</span>`}
      </div>

      <div class="grid g3" style="margin-top:10px;">
        <div>
          <label>3連単 1-2-3（auto/手）</label>
          <input data-o3t123 type="number" step="0.1">
        </div>
        <div>
          <label>3連単 1-3-2（auto/手）</label>
          <input data-o3t132 type="number" step="0.1">
        </div>
        <div>
          <label>3連複 1-2-3（auto/手）</label>
          <input data-o3f123 type="number" step="0.1">
        </div>
      </div>

      <div class="muted small" style="margin-top:8px;">
        直前（auto）：風=${autoBefore?.info?.windMs ?? "-"}m/s / 波=${autoBefore?.info?.waveCm ?? "-"}cm / 気温=${autoBefore?.info?.airTempC ?? "-"}℃ / 水温=${autoBefore?.info?.waterTempC ?? "-"}℃
      </div>
    ` : ``;

    const buyLine = isFinal
      ? `<div class="muted small">買い：<b>${plan.betType} ${plan.combo}</b>${Number.isFinite(ev.odd) ? ` / odds=${ev.odd} (${ev.odd_source||"-"})` : ``}</div>`
      : ``;

    card.innerHTML = `
      <div class="row">
        <div>
          <span class="pill">${r.venue} ${r.race}R</span>
          <span class="${badgeClass}">${ev.state}</span>
          <span class="tag">${r.date}</span>
          <span class="tag">${r.title}</span>
          <span class="tag mono">prog:${r._progAt||"-"} exh:${r._exhAt||"-"} res:${r._resAt||"-"}</span>
        </div>
        <div class="muted">全国${r.nat2}% / 当地${r.loc2}% / M${r.motor2}%</div>
      </div>

      <div class="grid g2" style="margin-top:10px;">
        <div class="muted">
          展示 1:${dispTime(r.exh["1"])} 2:${dispTime(r.exh["2"])} 3:${dispTime(r.exh["3"])}
          4:${dispTime(r.exh["4"])} 5:${dispTime(r.exh["5"])} 6:${dispTime(r.exh["6"])}
          ${r.result_top3 ? `<div class="resultLine">結果（参考）: ${r.result_top3}</div>` : ``}
          <div class="resultLine">払戻123（100円/自動）: 3連単=${Number.isFinite(r.final_payout_3t_123)?r.final_payout_3t_123:"未取得"} / 3連複=${Number.isFinite(r.final_payout_3f_123)?r.final_payout_3f_123:"未取得"}</div>
        </div>
        <div>
          ${buyLine}
        </div>
      </div>

      <div class="muted" style="margin-top:8px;">${ev.msg}</div>
      ${oddsBlock}
    `;

    if(isFinal){
      const inp3t123 = card.querySelector("[data-o3t123]");
      const inp3t132 = card.querySelector("[data-o3t132]");
      const inp3f123 = card.querySelector("[data-o3f123]");

      const a3t123 = autoOdds?.odds3t?.["1-2-3"];
      const a3t132 = autoOdds?.odds3t?.["1-3-2"];
      const a3f123 = autoOdds?.odds3f?.["1-2-3"];

      inp3t123.value = manual.o3t123 || (Number.isFinite(a3t123) ? String(a3t123) : "");
      inp3t132.value = manual.o3t132 || (Number.isFinite(a3t132) ? String(a3t132) : "");
      inp3f123.value = manual.o3f123 || (Number.isFinite(a3f123) ? String(a3f123) : "");

      const onInput = () => {
        setManualOdds(r.key, {
          o3t123: inp3t123.value,
          o3t132: inp3t132.value,
          o3f123: inp3f123.value
        });
        renderSummary(LAST_RACES);
        renderList(LAST_RACES);
      };

      inp3t123.addEventListener("input", onInput);
      inp3t132.addEventListener("input", onInput);
      inp3f123.addEventListener("input", onInput);
    }

    return card;
  }

  function renderList(races){
    const mode = $("viewMode").value;
    let show = races.slice();
    if(mode==="candidates") show = show.filter(r => passFilter1(r).ok);

    function stateRank(r){
      const ev = evaluate(r);
      if(ev.state==="BUY") return 0;
      if(ev.state==="WAIT") return 1;
      if(ev.state==="NO") return 2;
      return 3;
    }
    show.sort((a,b)=>(stateRank(a)-stateRank(b)) || a.venue.localeCompare(b.venue) || a.race-b.race);

    const list = $("list");
    list.innerHTML="";
    if(show.length===0){
      const box = document.createElement("div");
      box.className="muted";
      box.style.padding="10px";
      box.innerHTML = `
        表示できるレースがありません。<br/>
        ・候補のみ：条件①通過が0件の可能性<br/>
        <div style="margin-top:8px;">
          <button class="btn2" id="toAllBtn">全件表示に切り替える</button>
        </div>
      `;
      list.appendChild(box);
      box.querySelector("#toAllBtn").addEventListener("click", ()=>{
        $("viewMode").value="all";
        renderList(LAST_RACES);
      });
      return;
    }

    for(const r of show) list.appendChild(makeRaceCard(r));
  }

  // ---- build races from bundle (full refresh) ----
  function buildRacesFromBundle(bundle){
    const programs = bundle.programs?.programs || [];
    const previews = bundle.previews?.previews || [];
    const resultsObj = bundle.results || {};
    const results = resultsObj.results || resultsObj.races || [];

    const prevMap = new Map();
    for(const p of previews){
      prevMap.set(`${p.race_date}-${p.race_stadium_number}-${p.race_number}`, p);
    }
    const resMap = new Map();
    for(const rr of results){
      resMap.set(`${rr.race_date}-${rr.race_stadium_number}-${rr.race_number}`, rr);
    }

    const races=[];
    for(const pr of programs){
      const stadium = pr.race_stadium_number;
      if(!enabledStadiums.has(stadium)) continue;

      const key = `${pr.race_date}-${stadium}-${pr.race_number}`;
      const b1 = (pr.boats || []).find(b=>b.racer_boat_number===1);
      if(!b1) continue;

      const pv = prevMap.get(key);
      const exh={};
      if(pv && pv.boats){
        for(let lane=1; lane<=6; lane++){
          const obj = pv.boats[String(lane)] || pv.boats[lane] || null;
          const t = obj?.racer_exhibition_time ?? obj?.exhibition_time ?? null;
          if(t!=null) exh[String(lane)] = Number(t);
        }
      }

      const rr = resMap.get(key);
      const top3 = rr ? extractTop3(rr) : null;
      const pay = rr ? extractPayout123(rr) : {pay3t123:null, pay3f123:null};

      races.push({
        key,
        stadium,
        venue: VENUES[stadium],
        race: pr.race_number,
        date: pr.race_date,
        title: pr.race_title || "一般戦",
        nat2: Number(b1.racer_national_top_2_percent ?? 0),
        loc2: Number(b1.racer_local_top_2_percent ?? 0),
        motor2: Number(b1.racer_assigned_motor_top_2_percent ?? 0),
        exh,
        exhReady: exhReady(exh),
        result_top3: top3,
        final_payout_3t_123: pay.pay3t123,
        final_payout_3f_123: pay.pay3f123,
        _progAt: new Date().toLocaleTimeString(),
        _exhAt: new Date().toLocaleTimeString(),
        _resAt: new Date().toLocaleTimeString(),
      });
    }
    return races;
  }

  // ---- lite refresh merges previews/results only (programs fixed) ----
  function mergePreviewsResultsIntoExisting(bundle){
    const previews = bundle.previews?.previews || [];
    const resultsObj = bundle.results || {};
    const results = resultsObj.results || resultsObj.races || [];

    const prevMap = new Map();
    for(const p of previews){
      prevMap.set(`${p.race_date}-${p.race_stadium_number}-${p.race_number}`, p);
    }
    const resMap = new Map();
    for(const rr of results){
      resMap.set(`${rr.race_date}-${rr.race_stadium_number}-${rr.race_number}`, rr);
    }

    const t = new Date().toLocaleTimeString();

    for(const r of LAST_RACES){
      const pv = prevMap.get(r.key);
      if(pv && pv.boats){
        const exh={};
        for(let lane=1; lane<=6; lane++){
          const obj = pv.boats[String(lane)] || pv.boats[lane] || null;
          const tt = obj?.racer_exhibition_time ?? obj?.exhibition_time ?? null;
          if(tt!=null) exh[String(lane)] = Number(tt);
        }
        r.exh = exh;
        r.exhReady = exhReady(exh);
        r._exhAt = t;
      }

      const rr = resMap.get(r.key);
      if(rr){
        r.result_top3 = extractTop3(rr);
        const pay = extractPayout123(rr);
        r.final_payout_3t_123 = pay.pay3t123;
        r.final_payout_3f_123 = pay.pay3f123;
        r._resAt = t;
      }
    }
  }

  async function prefetchFinalCandidates(){
    const finals = LAST_RACES
      .map(r => ({r, plan: computePlan(r)}))
      .filter(x => x.plan.level==="final")
      .map(x => x.r);

    const limit = 3;
    let i=0;
    const running = new Set();
    async function runOne(r){
      try{
        await Promise.allSettled([ensureOddsAuto(r), ensureBeforeAuto(r)]);
      }catch(e){}
    }
    while(i<finals.length || running.size){
      while(i<finals.length && running.size<limit){
        const p = runOne(finals[i++]).finally(()=>running.delete(p));
        running.add(p);
      }
      if(running.size) await Promise.race(running);
    }

    renderSummary(LAST_RACES);
    renderList(LAST_RACES);
  }

  // ---- refresh controls ----
  let AUTO_TIMER=null;
  function clearAutoTimer(){ if(AUTO_TIMER){ clearTimeout(AUTO_TIMER); AUTO_TIMER=null; } }

  function maybeScheduleAutoRefresh(){
    clearAutoTimer();
    if(!$("autoRefresh").checked){ setAutoStatus("自動更新OFF"); return; }
    if(!LAST_RACES.length){ setAutoStatus("-"); return; }

    const need = LAST_RACES.some(r=>{
      if(!passFilter1(r).ok) return false;
      const plan = computePlan(r);
      if(plan.level==="wait") return true;
      if(plan.level==="final"){
        if(!ODDS_AUTO.has(r.key)) return true;
        if(!BEFORE_AUTO.has(r.key)) return true;
      }
      return false;
    });

    if(!need){ setAutoStatus("対象なし"); return; }
    setAutoStatus("20秒後に軽更新（previews/results）");
    AUTO_TIMER = setTimeout(refreshLite, 20000);
  }

  async function refreshFull(){
    try{
      setStatus("更新中（programs含む）…");
      const bundle = await fetchTodayBundle();
      LAST_PROGRAMS_SNAPSHOT = bundle.programs;

      LAST_RACES = buildRacesFromBundle(bundle);

      setStatus(`取得OK：${LAST_RACES.length}R / ${new Date().toLocaleTimeString()}`);
      renderSummary(LAST_RACES);
      renderList(LAST_RACES);

      await prefetchFinalCandidates();
      setExportStatus("準備OK");
      maybeScheduleAutoRefresh();
    } catch(e){
      setStatus("取得失敗");
      setExportStatus("取得失敗");
      maybeScheduleAutoRefresh();
    }
  }

  async function refreshLite(){
    try{
      setStatus("軽更新中（previews/results）…");
      const bundle = await fetchTodayBundle();

      mergePreviewsResultsIntoExisting(bundle);

      setStatus(`軽更新OK / ${new Date().toLocaleTimeString()}`);
      renderSummary(LAST_RACES);
      renderList(LAST_RACES);

      await prefetchFinalCandidates();
      maybeScheduleAutoRefresh();
    } catch(e){
      setStatus("軽更新失敗");
      maybeScheduleAutoRefresh();
    }
  }

  // ---- snapshot export ----
  function getCurrentSettings(){
    return {
      minNat2: num("minNat2"),
      minLoc2: num("minLoc2"),
      minMotor2: num("minMotor2"),
      maxTimeRank: num("maxTimeRank"),
      maxNearCount: num("maxNearCount"),
      nearEps: num("nearEps"),
      maxDelta2: num("maxDelta2"),
      maxDelta3: num("maxDelta3"),
      min23Gap: num("min23Gap"),
      oddsFilterOn: $("oddsFilterOn").checked,
      minOdds3t: num("minOdds3t"),
      maxOdds3t: num("maxOdds3t"),
      minOdds3f: num("minOdds3f"),
      maxOdds3f: num("maxOdds3f"),
      viewMode: $("viewMode").value,
      enabledStadiums: Array.from(enabledStadiums).sort((a,b)=>a-b),
    };
  }

  function buildSnapshot(){
    const now = new Date();
    const settings = getCurrentSettings();

    const races = LAST_RACES.map(r=>{
      const ev = evaluate(r);
      const plan = ev.plan || null;

      const autoOdds = ODDS_AUTO.get(r.key) || null;
      const autoBefore = BEFORE_AUTO.get(r.key) || null;

      const finals = (plan && plan.level==="final");
      const oddInfo = finals ? getOddWithSource(r, plan.betType, plan.combo) : { odd: null, source: "none" };

      // 手入力の中身も保存（後で比較できる）
      const manual = getManualOdds(r.key);

      return {
        key: r.key,
        date: r.date,
        stadiumId: r.stadium,
        venue: r.venue,
        race: r.race,
        title: r.title,

        nat2: r.nat2,
        loc2: r.loc2,
        motor2: r.motor2,

        exh: { ...r.exh },
        exhReady: !!r.exhReady,

        state: ev.state,
        message: ev.msg,

        planLevel: plan ? plan.level : null,
        betType: plan?.betType ?? null,
        combo: plan?.combo ?? null,
        reasons: plan?.reasons ?? (ev.state==="条件外" ? (passFilter1(r).reasons || []) : []),

        // plan details (デバッグ/分析用)
        rank: plan?.rank ?? null,
        outerFast: plan?.outerFast ?? null,
        d2: plan?.d2 ?? null,
        d3: plan?.d3 ?? null,
        nc: plan?.nc ?? null,

        odd: oddInfo.odd,
        odd_source: oddInfo.source,
        manualOdds: { ...manual },
        autoOddsScrapedAt: autoOdds?.scraped_at ?? null,
        autoOdds: autoOdds ? { odds3t: autoOdds.odds3t || null, odds3f: autoOdds.odds3f || null } : null,

        beforeScrapedAt: autoBefore?.scraped_at ?? null,
        before: autoBefore?.info ?? null,

        result_top3: r.result_top3 ?? null,
        final_payout_3t_123: Number.isFinite(r.final_payout_3t_123) ? r.final_payout_3t_123 : null,
        final_payout_3f_123: Number.isFinite(r.final_payout_3f_123) ? r.final_payout_3f_123 : null,

        // update times
        _progAt: r._progAt || null,
        _exhAt: r._exhAt || null,
        _resAt: r._resAt || null,
      };
    });

    // 集計も一緒に保存（後で日次比較しやすい）
    const summary = (() => {
      const total = races.length;
      const f1pass = races.filter(x => {
        const rr = LAST_RACES.find(z => z.key===x.key);
        return rr ? passFilter1(rr).ok : false;
      }).length;
      const buy = races.filter(x=>x.state==="BUY").length;
      const no = races.filter(x=>x.state==="NO").length;
      const wait = races.filter(x=>x.state==="WAIT").length;
      const out = races.filter(x=>x.state==="条件外").length;
      const finals = races.filter(x=>x.planLevel==="final").length;
      const oddsReady = races.filter(x=>x.autoOddsScrapedAt!=null).length;
      const beforeReady = races.filter(x=>x.beforeScrapedAt!=null).length;
      return { total, f1pass, finals, buy, no, wait, out, oddsReady, beforeReady };
    })();

    return {
      meta: {
        createdAtIso: now.toISOString(),
        createdAtLocal: now.toLocaleString(),
        workerBase: WORKER_BASE,
        note: "kyotei-v2 snapshot (for analysis).",
      },
      settings,
      summary,
      races,
    };
  }

  function downloadFile(filename, content, mime){
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  function pad2(n){ return String(n).padStart(2,"0"); }
  function formatYmdHmsForFile(d){
    return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}_${pad2(d.getHours())}${pad2(d.getMinutes())}${pad2(d.getSeconds())}`;
  }

  function csvEscape(s){
    const v = (s==null) ? "" : String(s);
    if (/[",\n]/.test(v)) return `"${v.replace(/"/g,'""')}"`;
    return v;
  }

  function buildSnapshotCsv(snapshot){
    const header = [
      "key","date","stadiumId","venue","race","title",
      "nat2","loc2","motor2",
      "exh1","exh2","exh3","exh4","exh5","exh6","exhReady",
      "state","betType","combo","odd","odd_source","reasons",
      "rank","outerFast","d2","d3","nc",
      "before_windMs","before_waveCm","before_airTempC","before_waterTempC",
      "result_top3","final_payout_3t_123","final_payout_3f_123",
      "autoOddsScrapedAt","beforeScrapedAt",
      "_progAt","_exhAt","_resAt",
    ];

    const lines = [];
    lines.push(header.join(","));

    for(const r of snapshot.races){
      const exh = r.exh || {};
      const reasons = Array.isArray(r.reasons) ? r.reasons.join(" / ") : "";
      const row = [
        r.key, r.date, r.stadiumId, r.venue, r.race, r.title,
        r.nat2, r.loc2, r.motor2,
        exh["1"] ?? "", exh["2"] ?? "", exh["3"] ?? "", exh["4"] ?? "", exh["5"] ?? "", exh["6"] ?? "", r.exhReady ? "TRUE" : "FALSE",
        r.state, r.betType ?? "", r.combo ?? "", r.odd ?? "", r.odd_source ?? "", reasons,
        r.rank ?? "", r.outerFast ?? "", r.d2 ?? "", r.d3 ?? "", r.nc ?? "",
        r.before?.windMs ?? "", r.before?.waveCm ?? "", r.before?.airTempC ?? "", r.before?.waterTempC ?? "",
        r.result_top3 ?? "", r.final_payout_3t_123 ?? "", r.final_payout_3f_123 ?? "",
        r.autoOddsScrapedAt ?? "", r.beforeScrapedAt ?? "",
        r._progAt ?? "", r._exhAt ?? "", r._resAt ?? "",
      ].map(csvEscape);

      lines.push(row.join(","));
    }
    return lines.join("\n");
  }

  function exportSnapshotJson(){
    if(!LAST_RACES.length){
      setExportStatus("保存不可：データ未取得");
      return;
    }
    const snap = buildSnapshot();
    const now = new Date();
    const fn = `kyotei_snapshot_${formatYmdHmsForFile(now)}.json`;
    downloadFile(fn, JSON.stringify(snap, null, 2), "application/json;charset=utf-8");
    setExportStatus(`保存OK：${fn}`);
  }

  function exportSnapshotCsv(){
    if(!LAST_RACES.length){
      setExportStatus("保存不可：データ未取得");
      return;
    }
    const snap = buildSnapshot();
    const now = new Date();
    const fn = `kyotei_snapshot_${formatYmdHmsForFile(now)}.csv`;
    const csv = buildSnapshotCsv(snap);
    downloadFile(fn, csv, "text/csv;charset=utf-8");
    setExportStatus(`保存OK：${fn}`);
  }

  // wiring
  $("refreshBtn").addEventListener("click", refreshFull);
  $("applyBtn").addEventListener("click", ()=>{ renderSummary(LAST_RACES); renderList(LAST_RACES); });

  $("autoRefresh").addEventListener("change", maybeScheduleAutoRefresh);
  $("viewMode").addEventListener("change", ()=>renderList(LAST_RACES));
  $("oddsFilterOn").addEventListener("change", ()=>{ renderSummary(LAST_RACES); renderList(LAST_RACES); });

  $("exportJsonBtn").addEventListener("click", exportSnapshotJson);
  $("exportCsvBtn").addEventListener("click", exportSnapshotCsv);

  $("clearLocalBtn").addEventListener("click", ()=>{
    clearManualOddsAll();
    setExportStatus("手入力オッズを全消去しました");
    renderSummary(LAST_RACES);
    renderList(LAST_RACES);
  });

  // init
  renderVenueChecks();
  refreshFull();
})();
</script>
</body>
</html>
